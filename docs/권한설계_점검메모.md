# 권한설계 점검 메모 (관리자/일반유저)

## 1) 현재 증상과 원인 후보

- **관리자끼리도 강의계획서가 서로 안 보임**
  - `class_plans.owner_id` 기반 RLS(소유자만 SELECT/UPDATE/DELETE)가 걸려 있으면 이런 현상이 발생합니다.
  - 코드상 `POST /api/class-plans`에서 항상 `owner_id = 로그인 사용자`로 저장합니다.

- **일반유저 권한이 코드/DB 설정과 엉켜 기능이 불안정**
  - 일부 기능은 서버 API에서 권한 체크(예: `/api/admin/*`)를 하지만,
  - 일부 기능은 인증/권한 체크 없이 호출되거나(예: 기존 `/api/ai/copy`, `/api/ai/design`)
  - 일부는 클라이언트에서 직접 Supabase 테이블에 접근(템플릿 등)하며 RLS에 의존합니다.
  - 또한 현재 Cursor(MCP)에서 조회되는 DB 스키마와 코드가 기대하는 테이블 스키마가 불일치할 수 있습니다(환경변수/프로젝트 연결 혼선).

## 2) 요구사항에 맞는 권한 모델(권장)

### 핵심 규칙

- **강의계획서(`class_plans`, `weekly_plan_items`, `fee_rows`)**
  - 관리자/일반유저 모두: **전체 CRUD 가능**
  - 즉, 소유자(owner) 제한을 **두지 않음**(공유 데이터)

- **그 외 기능/데이터**
  - 일반유저: **접근 불가**
  - 관리자: 접근 가능

### “역할(role)” 단일 기준

- 권장 단일 기준: `profiles.role` (`admin` | `user`)
- 서버에서 관리자 여부를 판단할 때는 `profiles.active`도 같이 확인하는 것을 권장합니다.

## 3) DB(RLS) 정석안 (SQL 예시)

> 아래는 “정석 RLS” 입니다.  
> 현재 프로젝트의 실제 테이블/정책 상태를 먼저 확인한 뒤 적용하세요.

### 3-1. 역할 판별 함수(권장)

```sql
-- profiles.role을 기준으로 현재 사용자의 role을 반환
create or replace function public.auth_role()
returns public.user_role
language sql
stable
security definer
set search_path = public
as $$
  select coalesce(
    (select role from public.profiles where id = auth.uid()),
    'user'::public.user_role
  );
$$;

create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select public.auth_role() = 'admin'::public.user_role;
$$;
```

### 3-2. 강의계획서: authenticated 전원 CRUD

```sql
alter table public.class_plans enable row level security;
alter table public.weekly_plan_items enable row level security;
alter table public.fee_rows enable row level security;

-- class_plans
drop policy if exists "class_plans_all_select" on public.class_plans;
drop policy if exists "class_plans_all_insert" on public.class_plans;
drop policy if exists "class_plans_all_update" on public.class_plans;
drop policy if exists "class_plans_all_delete" on public.class_plans;

create policy "class_plans_all_select"
on public.class_plans
for select
to authenticated
using (true);

create policy "class_plans_all_insert"
on public.class_plans
for insert
to authenticated
with check (true);

create policy "class_plans_all_update"
on public.class_plans
for update
to authenticated
using (true)
with check (true);

create policy "class_plans_all_delete"
on public.class_plans
for delete
to authenticated
using (true);

-- weekly_plan_items
create policy "weekly_plan_items_all"
on public.weekly_plan_items
for all
to authenticated
using (true)
with check (true);

-- fee_rows
create policy "fee_rows_all"
on public.fee_rows
for all
to authenticated
using (true)
with check (true);
```

> (선택) `owner_id`를 감사용으로만 쓰고 “변경 불가”로 만들고 싶으면, UPDATE 트리거로 `owner_id` 변경을 막는 쪽이 안전합니다.

### 3-3. 관리자 전용 테이블: admin만 ALL

```sql
-- 예: templates / template_blocks / activity_logs 등
-- (테이블 명은 실제 스키마에 맞춰 조정)

alter table public.templates enable row level security;
create policy "templates_admin_only"
on public.templates
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

alter table public.template_blocks enable row level security;
create policy "template_blocks_admin_only"
on public.template_blocks
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

alter table public.activity_logs enable row level security;
create policy "activity_logs_admin_select"
on public.activity_logs
for select
to authenticated
using (public.is_admin());
```

### 3-4. profiles: self read + admin read (업데이트는 최소화 권장)

```sql
alter table public.profiles enable row level security;

create policy "profiles_self_select"
on public.profiles
for select
to authenticated
using (id = auth.uid());

create policy "profiles_admin_select"
on public.profiles
for select
to authenticated
using (public.is_admin());
```

> 비밀번호 변경 플래그(`must_change_password`)를 유저가 직접 업데이트해야 한다면 `profiles` UPDATE 정책을 최소 범위로 추가하고, 필요시 트리거로 변경 가능 컬럼을 제한하세요.

## 4) 운영 체크리스트(강력 권장)

- **환경변수/프로젝트 일치 확인**
  - `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`가 “같은 Supabase 프로젝트”를 바라보는지 확인
  - Supabase 대시보드에서 실제로 `class_plans`, `profiles`, `templates` 등이 존재하는지 확인
- **정책 점검 SQL**
  - `select * from pg_policies where schemaname='public' and tablename in ('class_plans','weekly_plan_items','fee_rows','profiles','templates','template_blocks','activity_logs');`


